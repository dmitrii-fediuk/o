## 1. `Def`
~~~
Def(A):
```
B
```
~~~
будет обозначать, что для **понятия** `B` я использую **обозначение** `A`.

## 2. `Def_P`
~~~
Def_P(A):
```
B
```
~~~
будет обозначать, что `B` является для меня **проблемой**, и для этой проблемы я использую обозначение `A`.

## 3. `Def_C`
### 3.1.
~~~
Def_C(P, A):
```
B
```
~~~
будет означать, что для понятия `B` я **временно**, **только в рамках пункта** `P`, использую обозначение `A`.
Вне пункта `P` это правило не применяется: в частности, если до пункта `P` обозначение `A` имело другой смысл, то после пункта `P` обозначение `A` снова будет иметь этот смысл.
По сути, `Def_C` объявляет **локальную переменную** `A` с **областью действия** `P`.
В отличие от `Def_C`, `Def` объявляет **глобальную переменную** `A`.

### 3.2.
~~~
Def_C([P1, P2, …, Pn], A):
```
B
```
~~~
имеет значение, **аналогичное** пункту **3.1**, только в этом случае обозначение `A` имеет значение `B` в контексте **не одного пункта** `P`, а **всех** пунктов [`P1`, `P2`, …, `Pn`], **перечисленных** в квадратных скобках.

### 3.3.
~~~
Def_C([P1-Pn], A):
```
B
```
~~~
имеет значение, **аналогичное** пункту **3.2**, только в этом случае я в квадратных скобках не перечисляю все пункты `P1`, `P2`, …, `Pn`, а вместо этого указываю их **диапазон**.
Обозначение `A` имеет значение `B` в контексте **всех** пунктов этого диапазона, **включая** его **границы**: `P1` и `Pn`.

## 4. `Def_F`
### 4.1.
Def_C(4-5, `F`):
```
Факт: некое событие, которое случилось в описываем мной случае.
```

### 4.2.
~~~
Def_F:
```
B
```
~~~
будет обозначать, что `B` — это `F`.

### 4.3.
~~~
Def_F(A):
```
B
```
~~~
будет обозначать, что `B` — это `F`, и для него я использую обозначение `A`.

## 5. `Def_Ph`
### 5.1.
Def_C(5, `Ph`):
```
Феномен: `F`, который вызывает у меня удивление.
```

### 5.2.
~~~
Def_Ph(A):
```
B
```
~~~
будет обозначать, что `B` — это `Ph`, и для него я использую обозначение `A`.

## 6. `Def_H`
### 6.1.
Def_C(6, `H`):
```
Гипотеза: некое предположение, требующее проверки.
```

### 6.2.
~~~
Def_H(A):
```
B
```
~~~
будет обозначать, что `B` — это `H`, и для него я использую обозначение `A`.

## 7. `Def_Set`
### 7.1.
```
Def_Set(S, I)
```
будет обозначать, что `S` — множество всех возможных `I`.

### 7.2.
```
Def_Set(S, {I1, I2, …, In})
```
будет обозначать, что `S` — множество, заданное точным перечислением всех его элементов: {`I1`, `I2`, …, `In`}.

### 7.3.
~~~
Def_Set(S):
```
A
```
~~~
будет обозначать, что `S` — это некое множество, и `A` — это определение/описание `S`.

## 8. `Def_I`
### 8.1.
```
Def_I(I, S)
```
будет обозначать, что `I` ∈ `S` (`I` — элемент множества `S`).

### 8.2.
~~~
Def_I(I, S):
```
B
```
~~~
будет обозначать, что `I` ∈ `S` и `B` — определение `I`.

## 9. `Use`
```
Use(A)
```
будет обозначать, что в описываемой мной ситуации я использую `A`.

## 10. 
Def_Set(`Rs`):
```
Правила пунктов 1-9 выше
```

## 11.
Def_I(`R1`, `Rs`):
```
Правило пункта 1 выше
```

## 12.
N/A

## 13.
Def(`AIs`):
```
Современные AI, основанные на LLM и GPT.
В частности: Gemini 2.5 Pro.
```

## 14.
Def(`PT`):
```
A prompt: некий запрос пользователя к `AIs`
```

## 15.
Def(`PT`):
```
A prompt: некий запрос пользователя к `AIs`
```

## 16.
Def(`T`):
```
Задача формулирования `PT`
```

## 17.
Def(`L`):
```
Некий полуформальный или формальный язык для `T`
```

## 18.
Def_Set(`Ls`):
```
множество всех `L`
```

## 19.
Def_I(`L0`, `Ls`):
```
`L`, состоящий из правил `Rs`.
```

## 20.
Def(`LAs`):
```
`Ls`, альтернативные `L0`.
```

## 21.
Def_I(`LI`, `LAs`):
```
Некий `L`, лучше всего подходящий для `T` в моём случае (вместо `L0`)
```

## 22.
Def_H(`H1`):
```
Возможно, разрабатывая `L0` — я переизобретаю велосипед.
Возможно, что вместо него лучше использовать некий готовый `LI`.
```

## 23.
Def(`R1-A`):
```
Правило `L`, аналогичное `R1`.
```

## 24. Требования к `LI`
### 24.1.
`LI` должен быть не полностью формальным.
В частности, для `R1-A` я хочу оставить себе возможность описывать понятие естественным языком, а не только формальным.
Мне также удобно делать это описание многострочным.

### 24.2.
Крайне желательно, чтобы `LI` был совместим с синтаксисом Markdown (аналогично `L0`).
Другими словами, мне удобно, чтобы полный `PT` был документом с синтаксисом Markdown.


## 25. 
Def(`LI-R`):
```
Требования пункта 24 выше
```

## 26. Авторитетные источники информации для поиска `LI`
26.1) arxiv.org
26.2) GitHub
26.3) Reddit
26.4) сайты StackExchange
26.5) другие авторитетные источники на английском языке.

## 27. 
Def(`As`):
```
Авторитетные источники информации, перечисленные в пункте 26 выше
```

## 28. Твоя задача
1) 
1.1) Найди `Ls`, используя `As`.
1.2) Для каждого найденного `L` укажи его синтаксис для `R1-A`.  
2) На остальные вопросы не отвечай.
3) Уже известную мне информацию не пересказывай.
4) Обязательно используй свой режим «Deep Research».
Твой ответ без режима «Deep Research» — гарантированно неверный.
5) Свой ответ дай на русском языке. 
