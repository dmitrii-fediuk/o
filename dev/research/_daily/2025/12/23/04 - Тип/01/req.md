#
Я разрабатываю `᛭L`: свой полуформальный язык для описания онтологий (`᛭O`) для LLM.

#
Пусть `S` означает «balls», а `A` — «a ball».

#
Пусть `R` — это бинарное отношение между сущностями типа `S` и `A`.

# 
Сейчас у меня в `᛭L` есть следующий синтаксис (`S1`) для `R`:
```
#  ᗉ
## Syntax
~~~code
A ᗉ S
~~~
## Meaning
###
`A` — неопределённый элемент `S`.
`S` — некоторое множество/категория сущностей.
###
`S` может быть словесно определено словесно,
###
По смыслу `ᗉ` соответствует неопределённому артиклю «a / an» английского языка.
## Examples
###
`A ᗉ ⟨ balls ⟩` означает, что `A` — это «a ball».
###
`A ᗉ ⟨ ball ⟩` ≡ `A ᗉ ⟨ balls ⟩`
```

# 
##
Я тебя спросил:
~~~
Проанализируй: есть ли вообще разница между терминами «множество» / «тип» / «категория» / «класс» для обозначения `S` в контексте `R`.
В чём конкретно заключается эта разница?
~~~

## 
Ты ответил (`A1`):
~~~
https://gemini.google.com/share/446ecea0274c

## 1. Фундаментальное различие

Между указанными терминами существует строгая семантическая разница, которая определяет механизм валидации отношения `R`.
Выбор конкретного термина для `S` диктует то, каким именно образом интерпретатор языка `᛭L` должен проверять истинность утверждения `A ᗉ S`.
Эта разница заключается в природе требований, предъявляемых к структуре и происхождению сущности `A`.

## 2. Термин «Множество» (Set)

Термин «множество» отсылает к классической теории множеств и подразумевает экстенсиональное определение через перечисление элементов.
В этом контексте `S` является контейнером, а отношение `R` проверяет фактическое наличие `A` в этом контейнере (отношение принадлежности `∈`).
Сущность `A` считается валидной только в том случае, если она уже явно добавлена в коллекцию `S`.
Этот термин не накладывает требований на внутреннюю структуру `A`, а лишь фиксирует его присутствие в списке.

## 3. Термин «Тип» (Type)

Термин «тип» происходит из теории типов и информатики, определяя `S` интенсионально через набор правил и ограничений.
Использование этого термина означает, что `S` задаёт формальную спецификацию или интерфейс, которому должна соответствовать структура `A`.
Отношение `R` в данном случае (отношение типизации `:`) подтверждает, что `A` обладает необходимыми свойствами и поведением для данного типа.
Здесь `A` является «ball» не потому, что находится в списке, а потому, что его характеристики удовлетворяют определению `S`.

## 4. Термин «Класс» (Class)

Термин «класс» используется в объектно-ориентированном подходе и логике предикатов для построения иерархических таксономий.
Определение `S` как класса подразумевает, что `A` является экземпляром, порождённым по шаблону `S` и наследующим его метаданные.
Отношение `R` (отношение инстанцирования) фиксирует родо-видовую связь и место `A` в дереве классификации онтологии.
В отличие от типа, класс акцентирует внимание на происхождении объекта и его связях с родительскими понятиями.

## 5. Термин «Категория» (Category)

Термин «категория» имеет философский и когнитивный характер, обозначая широкую понятийную область с возможными нечёткими границами.
В этом случае `S` выступает как концепт, объединяющий сущности на основе семантического сходства, а не строгой структуры.
Отношение `R` интерпретируется как смысловое включение, где `A` распознаётся как разновидность сущности, описываемой понятием `S`.
Этот термин наиболее точно описывает естественные языковые конструкции, где группировка происходит по смыслу, а не по технической спецификации.

## 6. Итоговое различие в логике проверки

Если `S` определяется как «множество», то проверяется регистрация `A` в базе данных элементов.
Если `S` определяется как «тип», то валидируется соответствие внутренней структуры `A` формальным правилам.
Если `S` определяется как «класс», то отслеживается цепочка наследования и факт создания `A` по шаблону.
Если `S` определяется как «категория», то анализируется семантическая совместимость смысла `A` с понятием `S`.
~~~

#
`T`: термин «тип» из `A1`.

#
`OL`: язык описания онтологий.

# `᛭T`
##
Проанализируй 20 популярных `OL`: как там называется `T`?
##
Названия `T` пиши на английском языке.

#
По умолчанию отвечай на русском языке.

#
Не пиши в своём ответе самовольно введение / вступление.
Мне это пизобольство не нужно.
Вместо этого сразу отвечай конкретно, по существу `᛭T`.
##
В частности, не начинай свой ответ с бесполезных фраз типа «Хороший вопрос» и другого подобного мусора.

#
Не пиши в своём ответе самовольно заключение.
Мне это пизобольство не нужно.
Просто в точности выполни `᛭T`.
Экономь моё время: не мусори словами.
##
В частности, в конце своего ответа не задавай мне мусорные вопросы типа «Хотите я <…>?».
То, что я хочу — конкретно указано в `᛭T`.
Фокусируйся на `᛭T` и не навязывай мне другие свои услуги.

#
##
Каждый абзац твоего ответа должен содержать ровно одно предложение.
###
Mежду абзацами твоего ответа не должно оставаться пустых строк.

#
Никогда не используй жаргон.
Используй только официальные термины.

# Кавычки
##
Никогда не используй кавычки для жаргона (по той причине, что вообще в принципе не используй жаргон).
##
Используй кавычки только для точных терминов.
##
В качестве кавычек по умолчанию используй `«»`.
###
В частности, используй `«»` для элементов User Interface.
## 
В качестве кавычек точных сущностей в сферах математики, Computer Science и т. п. используй backticks.
###
В частности, заключай в backticks имена компьютерных файлов.
Например: `header.php`.

#
В разметке Markdown твоего ответа не используй `\` перед `.`, `[`, `]` и другими подобными символами.
## Пример
### Неправильное форматирование
```markdown
# 1\. Заголовок
```
### Правильное форматирование
```markdown
# 1. Заголовок
```

# Markdown / Заголовки
## Структура твоего ответа
### 
У твоего ответа не должно быть одного общего заголовка 1-го уровня (`#`), потому что твой ответ будет вставлен внутрь секции 1-го уровня (`#`) другого документа Markdown.
###
Исходя из предыдущего пункта, в качестве заголовков верхего уровня ты должен использовать заголовки 2-го уровня (`##`).
Таких заголовков должно быть несколько: тем самым ты разбиваешь свой ответ на разделы.
Если твой ответ краток, то не разбивай его на разделы вообще.
### 
Разумеется, ты также можешь использовать заголовки более нижних уровней внутри заголовков 2-го уровня: для дополнительной структуризации текста.

## 
Никогда не используй выделение жирным (`**`) в заголовках.

## 
Всегда форматируй заголовки только символами решётки (`#`), не другими способами. 

## 
Не вставляй самовольно полностью пустые строки после заголовков Markdown.
### Пример
#### Неправильное форматирование
```markdown
# Заголовок

Текст
```
#### Правильное форматирование
```markdown
# Заголовок
Текст
```

## Нумерация заголовков
### 
По умолчанию делай заголовки нумерованными.
###
Не меняй формат нумерации в `᛭A`, если тебе явно не сказано это делать.
#### 
В частности, если в `᛭A` используется нумерация `1)`, `2)`, `3)`, то не меняй самовольно `)` на `.` 

# Режим «Deep Research» / Общее
## 
Не пиши никаких эссе в режиме «Deep Research».
Просто выполни `᛭T`: больше ничего не надо.
Не пиши никаких «введений» / «вступлений» и «заключений».
##
Пиши кратко: я использую режим «Deep Research» для сбора точных фактов в Интернете, а не для чтений пустословия.
## 
Не создавай самовольно никаких иллюстраций.
Мне нужен только текст.

# Режим «Deep Research» / Требования к источникам информации / Общее
## 
Если `᛭T` не касается специфики не-англоговорящей страны, то в первую очередь используй источники информации на английском языке.
##
В первую очередь используй официальные источники информации.
###
В частности, для программного обеспечения в первую очередь используй его официальную документацию.
##
Большое внимание уделяй анализу опыта реальных пользователей.
Для этого в первую очередь используй источники информации, где пользователи могут высказывать своё мнение независимо от владельца источника информации:
- Reddit
- GitHub
- Сайты сети StackExchange
- Официальные форумы
- Неофициальные форумы
- Авторитетные сайты отзывов типа Trustpilot, sikayetvar.com и т.п.
